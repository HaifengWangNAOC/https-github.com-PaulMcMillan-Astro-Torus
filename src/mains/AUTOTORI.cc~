/*******************************************************************************
*                                                                              *
* AUTOTORUS.cc                                                                 *
*                                                                              *
* C++ code written by Walter Dehnen, 1994/95,                                  *
*                     Paul McMillan, 2007                                      *
* Oxford University, Department of Physics, Theoretical Physics.               *
* address: 1 Keble Road, Oxford OX1 3NP, United Kingdom                        *
* e-mail:  p.mcmillan1@physics.ox.ac.uk                                        *
*                                                                              *
*******************************************************************************/


#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <string>
#include "Fit.h"
#include "ebf.hpp"
#include "Torus.h"
#include "noPT.h"
#include "Isochrone.h"
#include "falPot.h"
#include "LogPot.h"
#include "Numerics.h"
#include "MiyamotoNagai.h"
#include "PJM_cline.h"

using std::cerr;



int main(int argc,char *argv[])
{
  int      flag,err=0;
  clock_t cpu0 = clock();
  double   dJ=0.003;
  Actions  J,oJ;
  Torus    *T;
  ifstream from;
  ofstream to;
  Potential *Phi;
  T = new Torus;
//---------------------------------------------------------------------------
  if(argc<3 || argc>6){
    cerr <<"Input: potential actions outlist (dJ=) (err=)\n\n"
	 <<"actions are given as a file with the actions JR Jz Jphi as first 3 "
	 << "entries in each line\n"
	 <<"This programme is a good way of finding tori.\n";
    exit(1);
  }
//---------------------------------------------------------------------------
//===========================================================================
// 1. Get target potential
  if(string(argv[1]) == "LogPotYST") {
    Phi = new LogPot(220.*Units::kms,0.8,0.,0.);
  } else {
    my_open(from,argv[1]);
    Phi = new GalaxyPotential(from);
    from.close();
  }
  //Phi = new MiyamotoNagai(1.*Units::G_i,1.,.45);
  //Phi = new LogPot(244.5*Units::kms,0.7,0.,0.);
  
// input actions
//  J[0] = atof(argv[2]); J[1] = atof(argv[3]); J[2] = atof(argv[4]);

  my_open(from,argv[2]);
  //TorusList Tlist(argv[3],"o");
  for(int i=4;i!=argc;i++) {
    bool understood=false;
    if(parse_comm_line(argv[i],"dJ=",dJ)) understood=true;
    if(parse_comm_line(argv[i],"err=",err)) understood=true;
    if(!understood) {
      cerr << "Input "<<argv[i]<<" not understood\n"; exit(1);
    }
  }
// Use the Torus member functions AutoTorus to take a first (weak) guess -------
  int nout = how_many_lines(from), nignore=0;
  if((nignore =entrys_in_line(from)-3) != 0) {
    if(nignore<0) {
      cerr << "too few entries per line\n"; exit(1);
    }
    cerr << "assuming that the first three entries per line are actions\n";
  }
    ebf::WriteString(string(argv[3]),"/log","Torus list","w");

  for(int i=0;i!=nout;i++) {
    from >> J;
    double dummy;
    for(int j=0;j!=nignore;j++) from >> dummy;
    flag = T->AutoFit(J,Phi,dJ,700,300,15,5,24,200,24,err);
    std::cout << J << ", flag = " << flag<< "\n" << std::flush;
    // Output. 
    // flag = 0  -> success
    // flag = -1 -> catastrophic breakage
    // flag = -2 -> target < dH <2*target
    // flag = -3 -> 2*target < dH
    // flag = -4 -> angle fit failed
    std::stringstream tor; tor << "t" << i+1;
    T->write_ebf(string(argv[3]),tor.str());
    //T->read_ebf(string(argv[3]),tor.str());


    //    Tlist.AddTorus(*T);
  }
  //    T->show(std::cout); // give ASCII output to screen.
  cerr << "time taken in seconds: " 
       << double(clock()-cpu0)/double(CLOCKS_PER_SEC) << "\n";
}





//   } else {
//     my_open(from,argv[2]);
//     if(argc==4) {
//       TorusList Tlist(argv[3],2);
//       while(!from.eof()) {
// 	from >> J;
// 	if(!(from.eof() && J == oJ)) {
// 	  //T->AutoTorus(Phi,J,3.);
// 	  flag = T->AutoFit(J,Phi,0.001,700,200,15,4,36,200,24,1);
// 	  std::cout << J << ", flag = " << flag<< "\n" << std::flush;
// 	  Tlist.AddTorus(*T);
// 	}
// 	oJ = J;
//       }
//     } else {
//       while(!from.eof()) {
// 	from >> J;
// 	if(!(from.eof() && J == oJ)) {
// 	  T->AutoTorus(Phi,J,3.);
// 	  flag = T->Fit(Phi,0.001,1200,300,15,3,24,200,24,0);
// 	  std::cout << J << ", flag = " << flag<< "\n\n" << std::flush;
// 	  T->show(std::cout);
// 	}
// 	oJ = J;
//       }
//     }
//   }
